# Rivet

Rivet is a stripped-down version of Hammer that aims to be very, very simple.

Rivet core contains a minimal feature set for managing flows involving command-based tools:
- Flow tree construction
- Checkpointing and restarts
- Freezing dependencies
- Tool invocation
- CLI driver

Additional features are implemented in PDK/tool plugins. Such features include:
- Parametric flows
- TCL templating
- Design sanity checks
- Input file bundling

## TODOs

- Think about checkpointing/pinning behavior and implement it
- Genus/Innovus/Sky130 plugins
- Move checkpointing logic into rivet
- Move execution and checkpoint logic into flow.rs

## Design

Information generated by the flow (e.g. checkpoints/outputs) is stored in files on disk.
Information is referenced by file path.

```rust
pub struct FlowNode {
    name: String,
    tool: Arc<dyn Tool>,
    steps: Vec<Step>,
    deps: Vec<Arc<FlowNode>>
}

pub trait Tool {
    /// The tool's work directory.
    fn work_dir(&self) -> PathBuf;

    /// Checkpoint paths for each step.
    fn checkpoints(&self, steps: Vec<Step>) -> Vec<PathBuf>;

    /// Runs the tool for the given steps.
    fn invoke(&self, steps: Vec<Step>);

    /// Writes a checkpoint to the given path.
    fn write_checkpoint(&self, path: impl AsRef<Path>) -> Step;

    /// Reads a checkpoint from the given path.
    fn read_checkpoint(&self, path: impl AsRef<Path>) -> Step;
}

pub struct Step {
    name: String,
    command: String,
    checkpoint: bool,
}
```

An invocation of a Rivet CLI driver might look like this:

```
cargo r --config Rivet.toml par
```

The `Rivet.toml` file contains configuration on which components of the flow to run, where to restart from, etc.
For example:

```toml
[syn]
start = "generic_syn"
checkpoint = "/tools/C/rahulkumar/decoder-vlsi/pre_generic_syn_db"

[par]
stop = "floorplan"
```

In this case, Rivet willrun all steps from the `generic_syn` step of synthesis up to the
`floorplan` step of PAR, using the checkpoint at
`/tools/C/rahulkumar/decoder-vlsi/pre_generic_syn_db` as a starting point.

The TOML can also be used to pin dependencies:

```toml
[par-ShuttleTile]
pin = true

[par-UciephyTestTL]
pin = true
output_dir = "/tools/C/rahulkumar/kodiak-cy/vlsi/build/par-UciephyTestTL"
```

In this case, `ShuttleTile` and `UciephyTestTL` will not be rerun PAR even if the desired target (e.g. top level PAR)
depends on those. The `UciephyTestTL` output will be taken `/tools/C/rahulkumar/kodiak-cy/vlsi/build/par-UciephyTestTL`
rather than the default build directory.

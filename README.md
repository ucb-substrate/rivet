# Rivet

Rivet core contains a minimal feature set for managing flows involving command-based tools:
- Flow tree construction
- Checkpointing and restarts
- Freezing dependencies
- Tool invocation
- CLI driver

Additional features are implemented in PDK/tool plugins. Such features include:
- Parametric flows
- TCL templating
- Design sanity checks
- Input file bundling

## MVP

- Demonstrate checkpointing on complex design with tree of hierarchical blocks (syn/par)
- Documentation website (probably hosted on GitHub pages, can just be Rust docs for now unless you want something more fancy)
- DRC/LVS clean design

## TODOs

- Document checkpointing/pinning behavior (in the README.md)
- Check whether everything that is being used is either globally installed or generated by Rivet
- Try with a Verilog design other than a decoder (e.g. an adder)

### Reach

- Make a more complex flow and test that with checkpointing
  - Tree with dependencies
  - Hierarchical ILM flow
- Make Pegasus plugin

## Design

Information generated by the flow (e.g. checkpoints/outputs) is stored in files on disk.
Information is referenced by file path.

```rust
pub struct FlowNode {
    pub tool: Arc<dyn Tool>,
    pub work_dir: PathBuf,
    pub checkpoint_dir: PathBuf,
    pub steps: Vec<Step>,
    pub deps: Vec<String>,
}

pub trait Tool: Debug {
    /// Runs the tool with the configured steps and checkpoint
    fn invoke(
        &self,
        work_dir: PathBuf,
        start_checkpoint: Option<PathBuf>,
        steps: Vec<AnnotatedStep>,
    );
}

pub struct Step {
    pub name: String,
    pub command: String,
    pub checkpoint: bool,
}
```

An invocation of a Rivet CLI driver might look like this:

```
cargo r --config Rivet.toml par
```

The `Rivet.toml` file contains configuration on which components of the flow to run, where to restart from, etc.
For example:

```toml
[syn]
start = "syn_generic"
checkpoint = "rivet/examples/decoder/build/syn-rundir/checkpoints/syn_generic.cpf"

[par]
stop = "floorplan_design"
```

In this case, Rivet will run all steps from the `syn_generic` step of synthesis up to the
`floorplan_design` step of PAR, using the checkpoint at
`rivet/examples/decoder/build/syn-rundir/checkpoints/syn_generic.cpf` as a starting point.

The TOML can also be used to pin dependencies:

```toml
[par-ShuttleTile]
pin = true

[par-UciephyTestTL]
pin = true
output_dir = "/tools/C/rahulkumar/kodiak-cy/vlsi/build/par-UciephyTestTL"
```

In this case, `ShuttleTile` and `UciephyTestTL` will not be rerun PAR even if the desired target (e.g. top level PAR)
depends on those. The `UciephyTestTL` output will be taken `/tools/C/rahulkumar/kodiak-cy/vlsi/build/par-UciephyTestTL`
rather than the default build directory.

# Simplified Hammer (Shammer)

Shammer is a stripped-down version of Hammer that aims to be very, very simple.

Shammer core contains a minimal feature set for managing linear flows involving command-based tools:
- Linear flow construction
- Checkpointing and restarts
- Tool invocation
- CLI driver

Additional features are implemented in PDK/tool plugins. Such features include:
- Parametric flows
- TCL templating
- Design sanity checks
- Input file bundling

## Design

Information generated by the flow (e.g. checkpoints/outputs) is stored in files on disk.
Information is referenced by file path.

```rust
pub struct Flow {
    invocations: Vec<ToolInvocation>
}

pub trait Tool {
    /// Checkpoint paths for each step.
    fn checkpoints(&self, steps: Vec<Step>) -> Vec<PathBuf>;

    /// Runs the tool for the given steps.
    fn invoke(&self, steps: Vec<Step>);

    /// Writes a checkpoint to the given path.
    fn write_checkpoint(&self, path: impl AsRef<Path>) -> Step;

    /// Reads a checkpoint from the given path.
    fn read_checkpoint(&self, path: impl AsRef<Path>) -> Step;
}

pub struct ToolInvocation {
    name: String,
    tool: Arc<dyn Tool>,
    steps: Vec<Step>
}

pub struct Step {
    name: String,
    command: String,
    checkpoint: bool,
}
```

An invocation of a Shammer CLI driver might look like this:

```
cargo r --start=syn.generic_syn --stop=par.floorplan --checkpoint=/tools/C/rahulkumar/decoder-vlsi/pre_generic_syn_db
```

This would run all steps from the `generic_syn` step of synthesis up to the floorplan step of PAR, using
the checkpoint at `/tools/C/rahulkumar/decoder-vlsi/pre_generic_syn_db` as a starting point.
